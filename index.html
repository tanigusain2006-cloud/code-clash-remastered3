<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>‚öîÔ∏è CODE CLASH - Multiplayer Coding Battle</title>
  <meta name="description" content="The Ultimate Multiplayer Coding Battle Arena - Create challenges and solve them in real-time!">
  <meta name="keywords" content="coding, programming, battle, multiplayer, javascript, challenges">
  <meta name="author" content="Code Clash Arena"><!-- GitHub Pages compatibility --> <base href="./"> <!-- Open Graph tags for better sharing -->
  <meta property="og:title" content="‚öîÔ∏è CODE CLASH - Multiplayer Coding Battle">
  <meta property="og:description" content="The Ultimate Multiplayer Coding Battle Arena">
  <meta property="og:type" content="website"><!-- PeerJS for real multiplayer -->
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700&family=Montserrat:wght@300;400;500;600;700;800&family=Playfair+Display:wght@400;500;600;700;800;900&display=swap');

        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Montserrat', sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a2332 25%, #2d3748 50%, #1a2332 75%, #0f1419 100%);
            background-size: 400% 400%;
            animation: stadiumLighting 20s ease infinite;
            min-height: 100%;
            color: #f7fafc;
            overflow-x: hidden;
            position: relative;
        }

        html {
            height: 100%;
        }

        @keyframes stadiumLighting {
            0%, 100% { background-position: 0% 50%; }
            25% { background-position: 100% 25%; }
            50% { background-position: 50% 100%; }
            75% { background-position: 25% 0%; }
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at 20% 10%, rgba(255, 215, 0, 0.06) 0%, transparent 40%),
                radial-gradient(ellipse at 80% 10%, rgba(255, 215, 0, 0.06) 0%, transparent 40%),
                radial-gradient(ellipse at 50% 90%, rgba(59, 130, 246, 0.04) 0%, transparent 50%);
            pointer-events: none;
            z-index: 1;
            animation: spotlightSweep 15s ease-in-out infinite;
        }

        @keyframes spotlightSweep {
            0%, 100% { 
                background: 
                    radial-gradient(ellipse at 20% 10%, rgba(255, 215, 0, 0.06) 0%, transparent 40%),
                    radial-gradient(ellipse at 80% 10%, rgba(255, 215, 0, 0.06) 0%, transparent 40%),
                    radial-gradient(ellipse at 50% 90%, rgba(59, 130, 246, 0.04) 0%, transparent 50%);
            }
            33% { 
                background: 
                    radial-gradient(ellipse at 50% 10%, rgba(255, 215, 0, 0.08) 0%, transparent 40%),
                    radial-gradient(ellipse at 30% 10%, rgba(255, 215, 0, 0.04) 0%, transparent 40%),
                    radial-gradient(ellipse at 70% 90%, rgba(59, 130, 246, 0.06) 0%, transparent 50%);
            }
            66% { 
                background: 
                    radial-gradient(ellipse at 80% 10%, rgba(255, 215, 0, 0.06) 0%, transparent 40%),
                    radial-gradient(ellipse at 20% 10%, rgba(255, 215, 0, 0.08) 0%, transparent 40%),
                    radial-gradient(ellipse at 30% 90%, rgba(59, 130, 246, 0.04) 0%, transparent 50%);
            }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100%;
            position: relative;
            z-index: 2;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            position: relative;
        }

        .title {
            font-family: 'Playfair Display', serif;
            font-size: 4.5rem;
            font-weight: 900;
            margin: 20px 0;
            background: linear-gradient(45deg, #ffd700, #fff, #ffd700, #fff, #ffd700);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: championGlow 3s ease-in-out infinite;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            letter-spacing: 3px;
            position: relative;
        }

        .title::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.2) 0%, transparent 70%);
            border-radius: 50%;
            animation: titleAura 4s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes championGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes titleAura {
            0%, 100% { transform: scale(1); opacity: 0.3; }
            50% { transform: scale(1.1); opacity: 0.6; }
        }

        .subtitle {
            font-family: 'Cinzel', serif;
            font-size: 1.4rem;
            margin: 20px 0;
            color: #ffd700;
            font-weight: 500;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        .energy-orbs {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .orb {
            position: absolute;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #ffd700, #ffed4e);
            border-radius: 50%;
            box-shadow: 0 0 20px #ffd700;
            animation: orbFloat 8s ease-in-out infinite;
        }

        .orb:nth-child(1) {
            left: 10%;
            animation-delay: 0s;
            animation-duration: 12s;
        }

        .orb:nth-child(2) {
            left: 30%;
            animation-delay: 2s;
            animation-duration: 10s;
        }

        .orb:nth-child(3) {
            left: 50%;
            animation-delay: 4s;
            animation-duration: 14s;
        }

        .orb:nth-child(4) {
            left: 70%;
            animation-delay: 6s;
            animation-duration: 9s;
        }

        .orb:nth-child(5) {
            left: 90%;
            animation-delay: 8s;
            animation-duration: 11s;
        }

        @keyframes orbFloat {
            0%, 100% {
                transform: translateY(100vh) translateX(0px);
                opacity: 0;
            }
            10%, 90% {
                opacity: 1;
            }
            25% {
                transform: translateY(75vh) translateX(20px);
            }
            50% {
                transform: translateY(50vh) translateX(-10px);
            }
            75% {
                transform: translateY(25vh) translateX(15px);
            }
        }

        .game-setup {
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.1) 0%, 
                rgba(59, 130, 246, 0.1) 50%, 
                rgba(255, 215, 0, 0.1) 100%);
            border-radius: 25px;
            padding: 40px;
            margin-bottom: 30px;
            backdrop-filter: blur(20px);
            border: 3px solid;
            border-image: linear-gradient(45deg, #ffd700, #3b82f6, #ffd700) 1;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.3),
                0 0 30px rgba(255, 215, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .game-setup::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 215, 0, 0.1), 
                transparent);
            animation: tournamentScan 5s infinite;
        }

        @keyframes tournamentScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .player-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        .input-group label {
            font-weight: 600;
            margin-bottom: 12px;
            font-size: 1.1rem;
            color: #ffd700;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.3);
        }

        .input-group input {
            padding: 18px 24px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 15px;
            font-size: 1.1rem;
            background: rgba(15, 20, 25, 0.8);
            color: #f7fafc;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-weight: 500;
            font-family: 'Montserrat', sans-serif;
        }

        .input-group input:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 
                0 0 25px rgba(255, 215, 0, 0.4),
                inset 0 0 15px rgba(255, 215, 0, 0.1);
            transform: translateY(-2px);
            background: rgba(255, 215, 0, 0.05);
        }

        .input-group input::placeholder {
            color: rgba(247, 250, 252, 0.5);
        }

        .start-btn {
            background: linear-gradient(45deg, 
                rgba(255, 215, 0, 0.9), 
                rgba(255, 237, 78, 0.9), 
                rgba(255, 215, 0, 0.9));
            border: 3px solid #ffd700;
            color: #1a202c;
            padding: 20px 50px;
            font-size: 1.4rem;
            font-weight: 800;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-family: 'Cinzel', serif;
            box-shadow: 
                0 10px 30px rgba(255, 215, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .start-btn:hover {
            transform: translateY(-4px);
            box-shadow: 
                0 15px 40px rgba(255, 215, 0, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.4);
            background: linear-gradient(45deg, 
                rgba(255, 215, 0, 1), 
                rgba(255, 237, 78, 1), 
                rgba(255, 215, 0, 1));
        }

        .start-btn:active {
            transform: translateY(-2px);
        }

        .start-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.3), 
                transparent);
            transition: left 0.6s;
        }

        .start-btn:hover::before {
            left: 100%;
        }

        .game-area {
            display: none;
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.08) 0%, 
                rgba(59, 130, 246, 0.08) 50%, 
                rgba(255, 215, 0, 0.08) 100%);
            border-radius: 30px;
            padding: 40px;
            backdrop-filter: blur(25px);
            border: 3px solid;
            border-image: linear-gradient(45deg, #ffd700, #3b82f6, #ffd700) 1;
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.3),
                0 0 40px rgba(255, 215, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .game-area::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, 
                transparent, 
                rgba(255, 215, 0, 0.03), 
                transparent, 
                rgba(59, 130, 246, 0.03), 
                transparent);
            animation: arenaRotate 20s linear infinite;
            pointer-events: none;
        }

        @keyframes arenaRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .round-info {
            font-size: 1.4rem;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        .timer {
            font-family: 'Cinzel', serif;
            font-size: 3rem;
            font-weight: 900;
            color: #ffd700;
            text-shadow: 
                0 0 15px #ffd700,
                0 0 30px #ffd700;
            border: 3px solid #ffd700;
            border-radius: 20px;
            padding: 20px 30px;
            backdrop-filter: blur(15px);
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.1) 0%, 
                rgba(59, 130, 246, 0.1) 100%);
            animation: championTimer 2s ease-in-out infinite;
            position: relative;
            overflow: hidden;
        }

        .timer::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 215, 0, 0.3), 
                transparent);
            animation: timerSweep 4s infinite;
        }

        @keyframes championTimer {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 
                    0 0 30px rgba(255, 215, 0, 0.3),
                    inset 0 0 20px rgba(255, 215, 0, 0.1);
            }
            50% { 
                transform: scale(1.03);
                box-shadow: 
                    0 0 40px rgba(255, 215, 0, 0.5),
                    inset 0 0 30px rgba(255, 215, 0, 0.2);
            }
        }

        @keyframes timerSweep {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .scores {
            display: flex;
            gap: 40px;
        }

        .score {
            text-align: center;
            background: rgba(255, 215, 0, 0.1);
            padding: 15px 25px;
            border-radius: 15px;
            border: 2px solid rgba(255, 215, 0, 0.3);
        }

        .score-label {
            font-size: 1rem;
            opacity: 0.9;
            font-weight: 600;
        }

        .score-value {
            font-size: 1.8rem;
            font-weight: 900;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .phase-content {
            margin-top: 30px;
        }

        .create-challenge {
            display: grid;
            gap: 25px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group label {
            font-weight: 600;
            margin-bottom: 10px;
            color: #ffd700;
        }

        .form-group input, .form-group textarea {
            padding: 15px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            font-size: 1rem;
            background: rgba(15, 20, 25, 0.8);
            color: #f7fafc;
            resize: vertical;
            font-family: 'Montserrat', sans-serif;
        }

        .form-group input:focus, .form-group textarea:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        .test-cases {
            display: grid;
            gap: 15px;
        }

        .test-case {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 15px;
            align-items: center;
        }

        .test-case input {
            padding: 12px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            background: rgba(15, 20, 25, 0.8);
            color: #f7fafc;
        }

        .remove-test {
            background: #ef4444;
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
        }

        .add-test {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
        }

        .submit-challenge {
            background: linear-gradient(45deg, #10b981, #3b82f6);
            color: white;
            border: none;
            padding: 18px 35px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .submit-challenge:hover {
            transform: translateY(-3px);
        }

        .solve-challenge {
            display: grid;
            gap: 25px;
        }

        .challenge-display {
            background: rgba(255, 215, 0, 0.1);
            padding: 25px;
            border-radius: 15px;
            border-left: 5px solid #ffd700;
            border: 2px solid rgba(255, 215, 0, 0.3);
        }

        .challenge-title {
            font-size: 1.6rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #ffd700;
        }

        .code-editor {
            background: #1a202c;
            border-radius: 10px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            color: #e2e8f0;
            border: 2px solid rgba(255, 215, 0, 0.3);
            width: 100%;
            min-height: 200px;
            font-size: 14px;
            resize: vertical;
        }

        .code-editor:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        .test-results {
            background: rgba(255, 215, 0, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-top: 15px;
            border: 2px solid rgba(255, 215, 0, 0.3);
        }

        .test-result {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 8px;
        }

        .test-result.pass {
            background: rgba(16, 185, 129, 0.2);
        }

        .test-result.fail {
            background: rgba(239, 68, 68, 0.2);
        }

        .run-code, .submit-solution {
            background: linear-gradient(45deg, #3b82f6, #10b981);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.1rem;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            margin-right: 15px;
        }

        .results-screen {
            text-align: center;
            padding: 50px;
        }

        .winner {
            font-size: 3rem;
            font-weight: 900;
            margin-bottom: 30px;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            font-family: 'Playfair Display', serif;
        }

        .final-scores {
            display: flex;
            justify-content: center;
            gap: 60px;
            margin-bottom: 40px;
        }

        .play-again {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #1a202c;
            border: none;
            padding: 18px 40px;
            font-size: 1.3rem;
            font-weight: bold;
            border-radius: 12px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
        }

        .hidden {
            display: none !important;
        }

        .mode-card:hover {
            transform: scale(1.05) !important;
            box-shadow: 0 15px 35px rgba(255, 215, 0, 0.3) !important;
        }

        .connection-status {
            background: rgba(59, 130, 246, 0.2);
            border: 2px solid #3b82f6;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            font-weight: bold;
        }

        .connection-status.connected {
            background: rgba(16, 185, 129, 0.2);
            border-color: #10b981;
            color: #10b981;
        }

        .connection-status.error {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
            color: #ef4444;
        }

        @media (max-width: 768px) {
            .player-inputs {
                grid-template-columns: 1fr;
            }
            
            .game-header {
                flex-direction: column;
                text-align: center;
            }
            
            .scores {
                justify-content: center;
            }
            
            .test-case {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .final-scores {
                flex-direction: column;
                gap: 30px;
            }
        }
    </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="/_sdk/element_sdk.js" type="text/javascript"></script>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
 </head>
 <body>
  <div class="container">
   <div class="energy-orbs">
    <div class="orb"></div>
    <div class="orb"></div>
    <div class="orb"></div>
    <div class="orb"></div>
    <div class="orb"></div>
   </div>
   <header class="header">
    <h1 class="title">‚öîÔ∏è CODE CLASH ‚öîÔ∏è</h1>
    <p class="subtitle">The Ultimate Multiplayer Coding Battle Arena</p>
   </header><!-- Game Mode Selection -->
   <div id="modeSelection" class="game-setup">
    <h2>üéÆ Choose Your Battle Mode</h2>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px;">
     <div class="mode-card" onclick="selectMode('algorithm')" style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(16, 185, 129, 0.2)); border: 3px solid rgba(59, 130, 246, 0.5); border-radius: 20px; padding: 30px; cursor: pointer; transition: all 0.3s ease; text-align: center;">
      <div style="font-size: 3rem; margin-bottom: 15px;">
       üß†
      </div>
      <h3 style="color: #3b82f6; margin: 15px 0;">Algorithm Battle</h3>
      <p style="margin: 0; opacity: 0.9;">Create and solve coding challenges with functions, logic, and test cases. Perfect for algorithmic thinking!</p>
     </div>
     <div class="mode-card" onclick="selectMode('pattern')" style="background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(239, 68, 68, 0.2)); border: 3px solid rgba(255, 215, 0, 0.5); border-radius: 20px; padding: 30px; cursor: pointer; transition: all 0.3s ease; text-align: center;">
      <div style="font-size: 3rem; margin-bottom: 15px;">
       üé®
      </div>
      <h3 style="color: #ffd700; margin: 15px 0;">Pattern Printing</h3>
      <p style="margin: 0; opacity: 0.9;">Create visual patterns and ASCII art for others to recreate with code. Great for creative coding!</p>
     </div>
    </div>
    <div id="selectedMode" style="background: rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 15px; text-align: center; display: none;">
     <h3 id="modeTitle">Selected Mode</h3>
     <p id="modeDescription">Mode description</p><button class="start-btn" onclick="showScoring()" style="margin-top: 15px;">Continue to Scoring Info üìä</button>
    </div>
   </div><!-- Scoring System Explanation -->
   <div id="scoringInfo" class="game-setup" style="display: none;">
    <h2>üèÜ How Scoring Works</h2>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 20px;">
     <div style="background: rgba(16, 185, 129, 0.2); padding: 20px; border-radius: 10px; border-left: 4px solid #10b981;">
      <h3 style="color: #10b981; margin-top: 0;">üìù Challenge Creation Points</h3>
      <div style="margin-bottom: 15px;"><strong>Base Score:</strong> 30 points<br><small>For creating any valid challenge</small>
      </div>
      <div style="margin-bottom: 15px;"><strong>Test Case Bonus:</strong> +10 points per test case<br><small>More test cases = better challenge quality</small>
      </div>
      <div style="margin-bottom: 15px;"><strong>Time Bonus:</strong> +0.5 points per second remaining<br><small>Finish early to earn extra points</small>
      </div>
      <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-family: monospace;"><strong>Example:</strong><br>
        Base: 30 + Test Cases: 3√ó10 + Time: 45 seconds left<br>
        = 30 + 30 + 22 = <strong>82 points</strong>
      </div>
     </div>
     <div style="background: rgba(59, 130, 246, 0.2); padding: 20px; border-radius: 10px; border-left: 4px solid #3b82f6;">
      <h3 style="color: #3b82f6; margin-top: 0;">üß© Problem Solving Points</h3>
      <div style="margin-bottom: 15px;"><strong>Correctness Score:</strong> 0-100 points<br><small>Based on % of test cases passed</small>
      </div>
      <div style="margin-bottom: 15px;"><strong>Time Bonus:</strong> +0.5 points per second remaining<br><small>Solve faster for bonus points</small>
      </div>
      <div style="margin-bottom: 15px;"><strong>Perfect Solution:</strong> All test cases pass<br><small>Get the full 100 base points</small>
      </div>
      <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-family: monospace;"><strong>Example:</strong><br>
        3/3 tests passed: 100 + Time: 30 seconds left<br>
        = 100 + 15 = <strong>115 points</strong>
      </div>
     </div>
    </div><button class="start-btn" onclick="hideScoring()">Enter The Arena üèÜ</button>
   </div><!-- Connection Setup -->
   <div id="connectionSetup" class="game-setup" style="display: none;">
    <h2>üåê Real Multiplayer Arena Setup</h2>
    <div id="connectionStatus" class="connection-status">
     üîÑ Initializing multiplayer system...
    </div>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px;">
     <div class="mode-card" onclick="hostGame()" style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(59, 130, 246, 0.2)); border: 3px solid rgba(16, 185, 129, 0.5); border-radius: 20px; padding: 30px; cursor: pointer; transition: all 0.3s ease; text-align: center;">
      <div style="font-size: 3rem; margin-bottom: 15px;">
       üëë
      </div>
      <h3 style="color: #10b981; margin: 15px 0;">Host Tournament</h3>
      <p style="margin: 0; opacity: 0.9;">Create a tournament room and invite friends to join with a code</p>
     </div>
     <div class="mode-card" onclick="showJoinForm()" style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(147, 51, 234, 0.2)); border: 3px solid rgba(59, 130, 246, 0.5); border-radius: 20px; padding: 30px; cursor: pointer; transition: all 0.3s ease; text-align: center;">
      <div style="font-size: 3rem; margin-bottom: 15px;">
       ‚öîÔ∏è
      </div>
      <h3 style="color: #3b82f6; margin: 15px 0;">Join Tournament</h3>
      <p style="margin: 0; opacity: 0.9;">Enter a friend's tournament code to join their battle</p>
     </div>
    </div>
    <div id="hostInterface" style="display: none; background: rgba(16, 185, 129, 0.1); padding: 25px; border-radius: 15px;">
     <h3 style="color: #10b981; text-align: center;">üèÜ Tournament Setup</h3>
     <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px;">
      <div class="input-group"><label for="maxPlayers">Max Players (2-6):</label> <select id="maxPlayers" style="padding: 15px; border: 2px solid rgba(255, 215, 0, 0.3); border-radius: 10px; background: rgba(15, 20, 25, 0.8); color: #f7fafc; font-size: 1rem;"> <option value="2">2 Players</option> <option value="3">3 Players</option> <option value="4" selected>4 Players</option> <option value="5">5 Players</option> <option value="6">6 Players</option> </select>
      </div>
      <div class="input-group"><label for="tournamentName">Tournament Name:</label> <input type="text" id="tournamentName" placeholder="Epic Code Battle" style="padding: 15px; border: 2px solid rgba(255, 215, 0, 0.3); border-radius: 10px; background: rgba(15, 20, 25, 0.8); color: #f7fafc;">
      </div>
     </div><button class="start-btn" onclick="createTournament()" style="margin-bottom: 20px;">üöÄ Create Tournament</button>
     <div id="tournamentLobby" style="display: none;">
      <div style="text-align: center; margin-bottom: 20px;">
       <h4 style="color: #ffd700;">üéØ Tournament Code</h4>
       <div id="connectionCode" style="font-family: 'Courier New', monospace; font-size: 2rem; font-weight: bold; color: #ffd700; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px; margin: 15px 0; letter-spacing: 3px;">
        Generating...
       </div>
       <p style="margin: 10px 0; opacity: 0.9;">Share this code with friends!</p>
      </div>
      <div id="playersList" style="background: rgba(0,0,0,0.2); padding: 20px; border-radius: 10px; margin-bottom: 20px;">
       <h4 style="color: #ffd700; margin-top: 0;">üë• Players in Lobby</h4>
       <div id="playersGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;"><!-- Players will be added here -->
       </div>
      </div>
      <div id="lobbyStatus" style="color: #ffd700; font-weight: bold; text-align: center; margin-bottom: 15px;">
       ‚è≥ Waiting for players to join...
      </div><button id="startTournamentBtn" class="start-btn" onclick="startTournament()" style="display: none;">üèÅ Start Tournament!</button>
     </div>
    </div>
    <div id="joinInterface" style="display: none; background: rgba(59, 130, 246, 0.1); padding: 25px; border-radius: 15px;">
     <h3 style="color: #3b82f6; text-align: center;">üîó Join Tournament</h3>
     <div class="input-group"><label for="joinCode">Tournament Code:</label> <input type="text" id="joinCode" placeholder="Enter tournament code" style="text-align: center; font-family: 'Courier New', monospace; font-size: 1.5rem; letter-spacing: 2px; text-transform: uppercase;" maxlength="20">
     </div><button class="start-btn" onclick="joinGame()" style="margin-top: 20px;">‚öîÔ∏è Join Tournament</button>
     <div id="joinStatus" style="color: #ffd700; font-weight: bold; margin-top: 15px; text-align: center;"></div>
    </div>
   </div><!-- Game Setup -->
   <div id="setup" class="game-setup" style="display: none;">
    <h2>üéÆ Championship Registration</h2>
    <div id="connectionInfo" style="background: rgba(16, 185, 129, 0.2); padding: 20px; border-radius: 15px; margin-bottom: 25px; text-align: center;">
     <div style="color: #10b981; font-weight: bold; font-size: 1.2rem;">
      ‚úÖ Connected Successfully!
     </div>
     <div style="margin-top: 10px; opacity: 0.9;">
      You are <span id="playerRole">Player 1</span>
     </div>
    </div>
    <div class="input-group"><label for="playerName">Your Champion Name:</label> <input type="text" id="playerName" placeholder="Enter your champion name" value="">
    </div><button class="start-btn" onclick="setPlayerName()" id="nameSubmitBtn">üèÜ READY FOR BATTLE!</button>
    <div id="waitingForOpponent" style="display: none; text-align: center; margin-top: 20px; color: #ffd700; font-weight: bold;">
     ‚è≥ Waiting for other players...
    </div>
   </div><!-- Game Area -->
   <div id="gameArea" class="game-area">
    <div class="game-header">
     <div class="round-info"><span id="roundInfo">Round 1 of 4</span>
      <div id="tournamentInfo" style="font-size: 1rem; opacity: 0.8; margin-top: 5px;"><span id="currentMatchup">Player vs Player</span>
      </div>
     </div>
     <div class="timer" id="timer">
      2:00
     </div>
     <div class="scores">
      <div id="tournamentScores" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; max-width: 600px;"><!-- Tournament scores will be populated here -->
      </div>
     </div>
    </div>
    <div class="phase-content"><!-- Create Challenge Phase - Algorithm Mode -->
     <div id="createPhase" class="create-challenge">
      <h3 id="creatorName">Your Turn - Create a Challenge!</h3>
      <div class="form-group"><label for="challengeTitle">Challenge Title:</label> <input type="text" id="challengeTitle" placeholder="e.g., Find the Maximum Number">
      </div>
      <div class="form-group"><label for="challengeDesc">Challenge Description:</label> <textarea id="challengeDesc" rows="3" placeholder="Describe what the function should do..."></textarea>
      </div>
      <div class="form-group"><label for="functionName">Function Name:</label> <input type="text" id="functionName" placeholder="e.g., findMax">
      </div>
      <div class="form-group"><label>Test Cases:</label>
       <div id="testCases" class="test-cases">
        <div class="test-case"><input type="text" placeholder="Input (e.g., [1,2,3])" class="test-input"> <input type="text" placeholder="Expected Output (e.g., 3)" class="test-output"> <button type="button" class="remove-test" onclick="removeTestCase(this)">‚úï</button>
        </div>
       </div><button type="button" class="add-test" onclick="addTestCase()">+ Add Test Case</button>
      </div><button class="submit-challenge" onclick="submitChallenge()">Submit Challenge</button>
     </div><!-- Create Pattern Phase -->
     <div id="createPatternPhase" class="create-challenge hidden">
      <h3 id="patternCreatorName">Your Turn - Create a Pattern!</h3>
      <div class="form-group"><label for="patternTitle">Pattern Title:</label> <input type="text" id="patternTitle" placeholder="e.g., Diamond Pattern, Number Triangle">
      </div>
      <div class="form-group"><label for="patternDesc">Pattern Description:</label> <textarea id="patternDesc" rows="2" placeholder="Describe the pattern (optional hints for the solver)..."></textarea>
      </div>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px;">
       <div class="form-group"><label for="patternInput">Your Pattern Code:</label> <textarea id="patternInput" class="code-editor" rows="12" placeholder="Write JavaScript code that creates your pattern using console.log()...

Example:
for(let i = 1; i <= 5; i++) {
    let line = '';
    for(let j = 1; j <= i; j++) {
        line += '* ';
    }
    console.log(line);
}"></textarea> <button type="button" class="run-code" onclick="testPattern()" style="margin-top: 10px;">‚ñ∂Ô∏è Test Pattern</button>
       </div>
       <div class="form-group"><label>Pattern Preview:</label>
        <div id="patternPreview" style="background: #1a202c; border-radius: 10px; padding: 20px; font-family: 'Courier New', monospace; color: #e2e8f0; border: 2px solid rgba(255, 215, 0, 0.3); min-height: 200px; white-space: pre-line; font-size: 14px;">
         Run your code to see the pattern preview...
        </div>
       </div>
      </div><button class="submit-challenge" onclick="submitPattern()">Submit Pattern Challenge</button>
     </div><!-- Solve Challenge Phase - Algorithm Mode -->
     <div id="solvePhase" class="solve-challenge hidden">
      <h3 id="solverName">Your Turn - Solve the Challenge!</h3>
      <div class="challenge-display">
       <div class="challenge-title" id="displayTitle">
        Challenge Title
       </div>
       <div id="displayDesc">
        Challenge description will appear here...
       </div>
       <div style="margin-top: 15px;"><strong>Function to implement:</strong>
        <div style="font-family: monospace; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin-top: 5px;"><span id="functionTemplate">function example() { }</span>
        </div>
       </div>
       <div style="margin-top: 15px;"><strong>Test Cases:</strong>
        <div id="displayTests"></div>
       </div>
      </div>
      <div class="form-group"><label for="codeEditor">Your Solution:</label> <textarea id="codeEditor" class="code-editor" placeholder="Write your JavaScript function here..."></textarea>
      </div>
      <div><button class="run-code" onclick="runCode()">‚ñ∂Ô∏è Test Code</button> <button class="submit-solution" onclick="submitSolution()">‚úÖ Submit Solution</button>
      </div>
      <div id="testResults" class="test-results hidden"></div>
     </div><!-- Solve Pattern Phase -->
     <div id="solvePatternPhase" class="solve-challenge hidden">
      <h3 id="patternSolverName">Your Turn - Recreate the Pattern!</h3>
      <div class="challenge-display">
       <div class="challenge-title" id="patternDisplayTitle">
        Pattern Challenge
       </div>
       <div id="patternDisplayDesc">
        Pattern description will appear here...
       </div>
       <div style="margin-top: 15px;"><strong>Target Pattern:</strong>
        <div id="targetPattern" style="font-family: 'Courier New', monospace; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 5px; margin-top: 5px; white-space: pre-line; font-size: 14px; border-left: 4px solid #ffd700;">
         Pattern will appear here...
        </div>
       </div>
       <div style="margin-top: 15px; background: rgba(255, 215, 0, 0.1); padding: 15px; border-radius: 8px;"><strong>üí° Your Goal:</strong> Write JavaScript code that produces the exact same pattern using console.log() statements.
       </div>
      </div>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px;">
       <div class="form-group"><label for="patternSolution">Your Pattern Code:</label> <textarea id="patternSolution" class="code-editor" rows="12" placeholder="Write JavaScript code to recreate the pattern...

Tip: Use loops, strings, and console.log() to match the target pattern exactly!"></textarea> <button class="run-code" onclick="runPatternCode()" style="margin-top: 10px;">‚ñ∂Ô∏è Test Your Pattern</button>
       </div>
       <div class="form-group"><label>Your Output:</label>
        <div id="patternOutput" style="background: #1a202c; border-radius: 10px; padding: 20px; font-family: 'Courier New', monospace; color: #e2e8f0; border: 2px solid rgba(59, 130, 246, 0.3); min-height: 200px; white-space: pre-line; font-size: 14px;">
         Your pattern output will appear here...
        </div>
       </div>
      </div>
      <div style="margin-top: 20px;"><button class="submit-solution" onclick="submitPatternSolution()">‚úÖ Submit Pattern Solution</button>
      </div>
      <div id="patternResults" class="test-results hidden"></div>
     </div><!-- Tournament Bracket -->
     <div id="tournamentBracket" class="hidden" style="background: rgba(255, 215, 0, 0.1); padding: 30px; border-radius: 20px; margin-bottom: 30px;">
      <h3 style="color: #ffd700; text-align: center; margin-bottom: 25px;">üèÜ Tournament Bracket</h3>
      <div id="bracketDisplay" style="display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 20px;"><!-- Bracket will be generated here -->
      </div>
      <div id="nextMatchInfo" style="text-align: center; margin-top: 20px; padding: 15px; background: rgba(59, 130, 246, 0.2); border-radius: 10px;">
       <div style="color: #3b82f6; font-weight: bold;">
        Next Match
       </div>
       <div id="nextMatchPlayers" style="font-size: 1.2rem; margin-top: 5px;">
        Preparing...
       </div>
      </div>
     </div><!-- Results Screen -->
     <div id="resultsScreen" class="results-screen hidden">
      <div class="winner" id="winnerText">
       üèÜ Tournament Champion!
      </div>
      <div id="finalRankings" style="background: rgba(255, 215, 0, 0.1); padding: 30px; border-radius: 20px; margin-bottom: 30px;">
       <h3 style="color: #ffd700; text-align: center; margin-bottom: 20px;">üèÖ Final Rankings</h3>
       <div id="rankingsList" style="display: grid; gap: 15px;"><!-- Rankings will be populated here -->
       </div>
      </div><button class="play-again" onclick="resetGame()">üîÑ New Tournament</button>
     </div>
    </div>
   </div>
  </div>
  <script>
        let gameState = {
            players: [],
            maxPlayers: 4,
            tournamentName: '',
            currentRound: 1,
            maxRounds: 4,
            currentMatch: { player1: null, player2: null },
            currentCreator: null,
            currentChallenge: null,
            timer: null,
            timeLeft: 120,
            phase: 'lobby',
            gameMode: 'algorithm',
            isHost: false,
            playerNumber: 0,
            connectionId: '',
            isConnected: false,
            bracket: [],
            currentBracketRound: 1,
            eliminatedPlayers: []
        };

        // Real Multiplayer System using PeerJS
        let peer = null;
        let connections = new Map();
        let isHost = false;
        let myPeerId = '';

        function selectMode(mode) {
            gameState.gameMode = mode;
            
            // Update mode selection UI
            document.querySelectorAll('.mode-card').forEach(card => {
                card.style.transform = 'scale(1)';
                card.style.opacity = '0.7';
            });
            
            event.target.closest('.mode-card').style.transform = 'scale(1.05)';
            event.target.closest('.mode-card').style.opacity = '1';
            
            // Show selected mode info
            const selectedDiv = document.getElementById('selectedMode');
            const titleEl = document.getElementById('modeTitle');
            const descEl = document.getElementById('modeDescription');
            
            if (mode === 'algorithm') {
                titleEl.textContent = 'üß† Algorithm Battle Selected';
                descEl.textContent = 'You\'ll create and solve coding challenges with functions, logic, and test cases. Perfect for algorithmic thinking and problem-solving skills!';
            } else {
                titleEl.textContent = 'üé® Pattern Printing Selected';
                descEl.textContent = 'You\'ll create visual patterns and ASCII art for others to recreate with code. Great for creative coding and visual thinking!';
            }
            
            selectedDiv.style.display = 'block';
        }

        function showScoring() {
            document.getElementById('modeSelection').style.display = 'none';
            document.getElementById('scoringInfo').style.display = 'block';
        }

        function hideScoring() {
            document.getElementById('scoringInfo').style.display = 'none';
            document.getElementById('connectionSetup').style.display = 'block';
            initializePeerJS();
        }

        function initializePeerJS() {
            const statusEl = document.getElementById('connectionStatus');
            statusEl.textContent = 'üîÑ Connecting to multiplayer servers...';
            statusEl.className = 'connection-status';
            
            try {
                // Create peer with random ID
                peer = new Peer({
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    }
                });
                
                peer.on('open', (id) => {
                    myPeerId = id;
                    gameState.connectionId = id.substring(0, 8).toUpperCase();
                    
                    statusEl.textContent = '‚úÖ Connected to multiplayer servers!';
                    statusEl.className = 'connection-status connected';
                    
                    console.log('Peer connected with ID:', id);
                });
                
                peer.on('connection', (conn) => {
                    if (isHost) {
                        handleNewConnection(conn);
                    }
                });
                
                peer.on('error', (err) => {
                    console.error('PeerJS error:', err);
                    statusEl.textContent = '‚ùå Connection failed: ' + err.message;
                    statusEl.className = 'connection-status error';
                    
                    // Retry connection after 3 seconds
                    setTimeout(() => {
                        initializePeerJS();
                    }, 3000);
                });
                
            } catch (error) {
                console.error('Failed to initialize PeerJS:', error);
                statusEl.textContent = '‚ùå Failed to initialize multiplayer system';
                statusEl.className = 'connection-status error';
            }
        }

        function hostGame() {
            if (!peer || !myPeerId) {
                showMessage('Please wait for connection to establish');
                return;
            }
            
            document.getElementById('hostInterface').style.display = 'block';
            document.getElementById('joinInterface').style.display = 'none';
        }

        function createTournament() {
            const maxPlayers = parseInt(document.getElementById('maxPlayers').value);
            const tournamentName = document.getElementById('tournamentName').value.trim() || 'Epic Code Battle';
            
            gameState.isHost = true;
            gameState.playerNumber = 1;
            gameState.maxPlayers = maxPlayers;
            gameState.tournamentName = tournamentName;
            gameState.phase = 'lobby';
            isHost = true;
            
            // Add host as first player
            gameState.players = [{
                id: 1,
                name: 'Host',
                score: 0,
                isActive: true,
                isHost: true,
                peerId: myPeerId
            }];
            
            document.getElementById('connectionCode').textContent = myPeerId;
            document.getElementById('tournamentLobby').style.display = 'block';
            updatePlayersDisplay();
            
            showMessage('Tournament created! Share your Peer ID: ' + myPeerId);
        }

        function showJoinForm() {
            document.getElementById('hostInterface').style.display = 'none';
            document.getElementById('joinInterface').style.display = 'block';
        }

        function joinGame() {
            const code = document.getElementById('joinCode').value.trim();
            if (!code) {
                showMessage('Please enter a tournament code!');
                return;
            }
            
            if (!peer || !myPeerId) {
                showMessage('Please wait for connection to establish');
                return;
            }
            
            gameState.isHost = false;
            isHost = false;
            
            document.getElementById('joinStatus').textContent = 'üîÑ Connecting to tournament...';
            
            connectToPeer(code);
        }

        function connectToPeer(peerId) {
            try {
                const conn = peer.connect(peerId);
                
                conn.on('open', () => {
                    connections.set('host', conn);
                    gameState.isConnected = true;
                    
                    // Send join request
                    conn.send({
                        type: 'joinRequest',
                        playerName: 'Player',
                        peerId: myPeerId
                    });
                    
                    document.getElementById('joinStatus').textContent = '‚úÖ Connected! Waiting for host response...';
                });
                
                conn.on('data', (data) => {
                    handleRemoteMessage(data, conn);
                });
                
                conn.on('error', (err) => {
                    console.error('Connection error:', err);
                    document.getElementById('joinStatus').textContent = '‚ùå Connection failed';
                    showMessage('Failed to connect to tournament');
                });
                
                conn.on('close', () => {
                    document.getElementById('joinStatus').textContent = '‚ùå Connection lost';
                    showMessage('Connection to host lost');
                });
                
            } catch (error) {
                console.error('Failed to connect:', error);
                document.getElementById('joinStatus').textContent = '‚ùå Invalid tournament code';
                showMessage('Invalid tournament code');
            }
        }

        function handleNewConnection(conn) {
            if (gameState.players.length >= gameState.maxPlayers) {
                conn.send({ type: 'roomFull' });
                conn.close();
                return;
            }
            
            const playerId = gameState.players.length + 1;
            
            conn.on('open', () => {
                connections.set(playerId, conn);
                
                console.log('New player connected:', playerId);
            });
            
            conn.on('data', (data) => {
                handleRemoteMessage(data, conn);
            });
            
            conn.on('close', () => {
                // Handle player disconnect
                connections.delete(playerId);
                gameState.players = gameState.players.filter(p => p.id !== playerId);
                updatePlayersDisplay();
                
                broadcastToAll({
                    type: 'playerLeft',
                    playerId: playerId,
                    players: gameState.players
                });
            });
        }

        function handleRemoteMessage(data, conn) {
            console.log('Received message:', data);
            
            switch (data.type) {
                case 'joinRequest':
                    if (isHost && gameState.players.length < gameState.maxPlayers) {
                        const playerId = gameState.players.length + 1;
                        
                        // Add new player
                        const newPlayer = {
                            id: playerId,
                            name: `Player ${playerId}`,
                            score: 0,
                            isActive: true,
                            isHost: false,
                            peerId: data.peerId
                        };
                        
                        gameState.players.push(newPlayer);
                        connections.set(playerId, conn);
                        updatePlayersDisplay();
                        
                        // Send welcome message
                        conn.send({
                            type: 'joinResponse',
                            success: true,
                            playerNumber: playerId,
                            gameState: gameState
                        });
                        
                        // Broadcast to all other players
                        broadcastToAll({
                            type: 'playerJoined',
                            player: newPlayer,
                            players: gameState.players
                        }, playerId);
                        
                    } else {
                        conn.send({ type: 'joinResponse', success: false, reason: 'Tournament full' });
                    }
                    break;
                    
                case 'joinResponse':
                    if (data.success) {
                        gameState.playerNumber = data.playerNumber;
                        Object.assign(gameState, data.gameState);
                        
                        document.getElementById('joinStatus').textContent = '‚úÖ Joined tournament successfully!';
                        
                        setTimeout(() => {
                            document.getElementById('connectionSetup').style.display = 'none';
                            document.getElementById('setup').style.display = 'block';
                            document.getElementById('playerRole').textContent = `Player ${gameState.playerNumber}`;
                            document.getElementById('playerName').value = `Player ${gameState.playerNumber}`;
                        }, 1500);
                    } else {
                        document.getElementById('joinStatus').textContent = '‚ùå ' + (data.reason || 'Failed to join');
                    }
                    break;
                    
                case 'playerJoined':
                    gameState.players = data.players;
                    if (document.getElementById('playersGrid')) {
                        updatePlayersDisplay();
                    }
                    break;
                    
                case 'playerLeft':
                    gameState.players = data.players;
                    if (document.getElementById('playersGrid')) {
                        updatePlayersDisplay();
                    }
                    break;
                    
                case 'playerName':
                    // Update player name
                    const player = gameState.players.find(p => p.id === data.playerNumber);
                    if (player) {
                        player.name = data.name;
                        updatePlayersDisplay();
                    }
                    checkAllPlayersReady();
                    break;
                    
                case 'tournamentStart':
                    Object.assign(gameState, data.gameState);
                    
                    document.getElementById('connectionSetup').style.display = 'none';
                    document.getElementById('setup').style.display = 'none';
                    document.getElementById('gameArea').style.display = 'block';
                    document.getElementById('tournamentBracket').classList.remove('hidden');
                    
                    updateTournamentDisplay();
                    break;
                    
                case 'gameState':
                    Object.assign(gameState, data.state);
                    updateUI();
                    syncGamePhase();
                    break;
                    
                case 'challenge':
                    gameState.currentChallenge = data.challenge;
                    if (gameState.playerNumber !== gameState.currentCreator) {
                        startSolvePhase();
                    }
                    break;
                    
                case 'solution':
                    if (gameState.playerNumber === gameState.currentCreator) {
                        handleRemoteSolution(data);
                    }
                    break;
                    
                case 'timer':
                    gameState.timeLeft = data.timeLeft;
                    updateTimerDisplay();
                    break;
                    
                case 'roomFull':
                    document.getElementById('joinStatus').textContent = '‚ùå Tournament is full';
                    break;
            }
        }

        function broadcastToAll(message, excludeId = null) {
            connections.forEach((conn, playerId) => {
                if (playerId !== excludeId && conn.open) {
                    conn.send(message);
                }
            });
        }

        function sendMessage(data) {
            if (isHost) {
                broadcastToAll(data);
            } else {
                const hostConnection = connections.get('host');
                if (hostConnection && hostConnection.open) {
                    hostConnection.send(data);
                }
            }
        }

        function updatePlayersDisplay() {
            const playersGrid = document.getElementById('playersGrid');
            if (!playersGrid) return;
            
            playersGrid.innerHTML = '';
            
            gameState.players.forEach(player => {
                const playerCard = document.createElement('div');
                playerCard.style.cssText = `
                    background: ${player.isHost ? 'rgba(255, 215, 0, 0.2)' : 'rgba(59, 130, 246, 0.2)'};
                    border: 2px solid ${player.isHost ? '#ffd700' : '#3b82f6'};
                    border-radius: 10px;
                    padding: 15px;
                    text-align: center;
                    position: relative;
                `;
                
                playerCard.innerHTML = `
                    <div style="font-size: 1.5rem; margin-bottom: 8px;">
                        ${player.isHost ? 'üëë' : '‚öîÔ∏è'}
                    </div>
                    <div style="font-weight: bold; color: ${player.isHost ? '#ffd700' : '#3b82f6'};">
                        ${player.name}
                    </div>
                    <div style="font-size: 0.9rem; opacity: 0.8; margin-top: 5px;">
                        ${player.isHost ? 'Tournament Host' : `Player ${player.id}`}
                    </div>
                `;
                
                playersGrid.appendChild(playerCard);
            });
            
            // Update status
            const statusEl = document.getElementById('lobbyStatus');
            const startBtn = document.getElementById('startTournamentBtn');
            
            if (statusEl && startBtn) {
                if (gameState.players.length >= 2) {
                    statusEl.textContent = `‚úÖ ${gameState.players.length}/${gameState.maxPlayers} players ready!`;
                    if (gameState.isHost) {
                        startBtn.style.display = 'block';
                    }
                } else {
                    statusEl.textContent = `‚è≥ ${gameState.players.length}/${gameState.maxPlayers} players joined (minimum 2 needed)`;
                    startBtn.style.display = 'none';
                }
            }
        }

        function setPlayerName() {
            const name = document.getElementById('playerName').value.trim();
            if (!name) {
                showMessage('Please enter your champion name!');
                return;
            }
            
            // Update player name in the players array
            const player = gameState.players.find(p => p.id === gameState.playerNumber);
            if (player) {
                player.name = name;
            }
            
            // Send name to other players
            sendMessage({
                type: 'playerName',
                name: name,
                playerNumber: gameState.playerNumber
            });
            
            document.getElementById('nameSubmitBtn').style.display = 'none';
            document.getElementById('waitingForOpponent').style.display = 'block';
            
            checkAllPlayersReady();
        }

        function checkAllPlayersReady() {
            const allPlayersHaveNames = gameState.players.every(p => 
                p.name && p.name !== 'Host' && !p.name.startsWith('Player ')
            );
            
            if (allPlayersHaveNames && gameState.isHost) {
                document.getElementById('waitingForOpponent').innerHTML = `
                    <div style="color: #10b981; font-weight: bold; margin-bottom: 15px;">‚úÖ All players ready!</div>
                    <button class="start-btn" onclick="startTournamentFromSetup()">üèÅ Begin Tournament!</button>
                `;
            }
        }

        function startTournament() {
            if (gameState.players.length < 2) {
                showMessage('Need at least 2 players to start the tournament!');
                return;
            }
            
            generateTournamentBracket();
            
            document.getElementById('connectionSetup').style.display = 'none';
            document.getElementById('gameArea').style.display = 'block';
            document.getElementById('tournamentBracket').classList.remove('hidden');
            
            gameState.phase = 'tournament';
            updateTournamentDisplay();
            
            startNextMatch();
            
            // Broadcast tournament start
            sendMessage({
                type: 'tournamentStart',
                gameState: gameState
            });
        }

        function startTournamentFromSetup() {
            startTournament();
        }

        function generateTournamentBracket() {
            const shuffledPlayers = [...gameState.players].sort(() => Math.random() - 0.5);
            
            gameState.bracket = [];
            gameState.currentBracketRound = 1;
            
            // Create first round matches
            const firstRound = [];
            for (let i = 0; i < shuffledPlayers.length; i += 2) {
                if (i + 1 < shuffledPlayers.length) {
                    firstRound.push({
                        player1: shuffledPlayers[i],
                        player2: shuffledPlayers[i + 1],
                        winner: null,
                        completed: false
                    });
                } else {
                    // Bye for odd number of players
                    firstRound.push({
                        player1: shuffledPlayers[i],
                        player2: null,
                        winner: shuffledPlayers[i],
                        completed: true
                    });
                }
            }
            
            gameState.bracket.push(firstRound);
            
            // Generate subsequent rounds
            let currentRoundSize = Math.ceil(shuffledPlayers.length / 2);
            while (currentRoundSize > 1) {
                const nextRound = [];
                for (let i = 0; i < Math.ceil(currentRoundSize / 2); i++) {
                    nextRound.push({
                        player1: null,
                        player2: null,
                        winner: null,
                        completed: false
                    });
                }
                gameState.bracket.push(nextRound);
                currentRoundSize = Math.ceil(currentRoundSize / 2);
            }
        }

        function updateUI() {
            if (gameState.phase === 'tournament') {
                updateTournamentDisplay();
            }
        }

        function updateTournamentDisplay() {
            const roundInfo = document.getElementById('roundInfo');
            if (gameState.currentBracketRound <= gameState.bracket.length) {
                const roundNames = ['First Round', 'Quarterfinals', 'Semifinals', 'Finals'];
                const roundName = roundNames[gameState.currentBracketRound - 1] || `Round ${gameState.currentBracketRound}`;
                roundInfo.textContent = `${roundName} - ${gameState.tournamentName}`;
            }
            
            const matchupEl = document.getElementById('currentMatchup');
            if (gameState.currentMatch.player1 && gameState.currentMatch.player2) {
                matchupEl.textContent = `${gameState.currentMatch.player1.name} vs ${gameState.currentMatch.player2.name}`;
            } else {
                matchupEl.textContent = 'Preparing next match...';
            }
            
            updateTournamentScores();
            updateBracketDisplay();
        }

        function updateTournamentScores() {
            const scoresContainer = document.getElementById('tournamentScores');
            scoresContainer.innerHTML = '';
            
            const activePlayers = gameState.players.filter(p => p.isActive);
            const eliminatedPlayers = gameState.eliminatedPlayers;
            
            [...activePlayers, ...eliminatedPlayers].forEach(player => {
                const scoreCard = document.createElement('div');
                scoreCard.className = 'score';
                scoreCard.style.cssText += player.isActive ? '' : 'opacity: 0.5; background: rgba(239, 68, 68, 0.2);';
                
                scoreCard.innerHTML = `
                    <div class="score-label" style="font-size: 0.9rem;">
                        ${player.isActive ? 'üèÜ' : '‚ùå'} ${player.name}
                    </div>
                    <div class="score-value" style="font-size: 1.4rem;">${player.score}</div>
                `;
                
                scoresContainer.appendChild(scoreCard);
            });
        }

        function updateBracketDisplay() {
            const bracketDisplay = document.getElementById('bracketDisplay');
            bracketDisplay.innerHTML = '';
            
            gameState.bracket.forEach((round, roundIndex) => {
                const roundDiv = document.createElement('div');
                roundDiv.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                    margin: 0 15px;
                `;
                
                const roundTitle = document.createElement('div');
                roundTitle.style.cssText = `
                    text-align: center;
                    font-weight: bold;
                    color: #ffd700;
                    margin-bottom: 10px;
                    font-size: 0.9rem;
                `;
                const roundNames = ['Round 1', 'Round 2', 'Semifinals', 'Finals'];
                roundTitle.textContent = roundNames[roundIndex] || `Round ${roundIndex + 1}`;
                roundDiv.appendChild(roundTitle);
                
                round.forEach(match => {
                    const matchDiv = document.createElement('div');
                    matchDiv.style.cssText = `
                        background: ${match.completed ? 'rgba(16, 185, 129, 0.2)' : 'rgba(59, 130, 246, 0.2)'};
                        border: 2px solid ${match.completed ? '#10b981' : '#3b82f6'};
                        border-radius: 8px;
                        padding: 10px;
                        min-width: 150px;
                        text-align: center;
                        font-size: 0.8rem;
                    `;
                    
                    if (match.player2 === null) {
                        matchDiv.innerHTML = `
                            <div style="font-weight: bold;">${match.player1.name}</div>
                            <div style="opacity: 0.7;">BYE</div>
                        `;
                    } else {
                        matchDiv.innerHTML = `
                            <div style="font-weight: bold; ${match.winner === match.player1 ? 'color: #10b981;' : ''}">${match.player1?.name || 'TBD'}</div>
                            <div style="margin: 5px 0;">vs</div>
                            <div style="font-weight: bold; ${match.winner === match.player2 ? 'color: #10b981;' : ''}">${match.player2?.name || 'TBD'}</div>
                        `;
                    }
                    
                    roundDiv.appendChild(matchDiv);
                });
                
                bracketDisplay.appendChild(roundDiv);
                
                if (roundIndex < gameState.bracket.length - 1) {
                    const arrow = document.createElement('div');
                    arrow.style.cssText = `
                        display: flex;
                        align-items: center;
                        font-size: 1.5rem;
                        color: #ffd700;
                    `;
                    arrow.textContent = '‚Üí';
                    bracketDisplay.appendChild(arrow);
                }
            });
        }

        function startNextMatch() {
            const currentRound = gameState.bracket[gameState.currentBracketRound - 1];
            const nextMatch = currentRound.find(match => !match.completed && match.player1 && match.player2);
            
            if (nextMatch) {
                gameState.currentMatch = {
                    player1: nextMatch.player1,
                    player2: nextMatch.player2
                };
                
                gameState.currentCreator = Math.random() < 0.5 ? nextMatch.player1.id : nextMatch.player2.id;
                
                updateTournamentDisplay();
                
                const nextMatchEl = document.getElementById('nextMatchPlayers');
                if (nextMatchEl) {
                    nextMatchEl.textContent = `${nextMatch.player1.name} vs ${nextMatch.player2.name}`;
                }
                
                startCreatePhase();
            } else {
                if (currentRound && currentRound.every(match => match.completed)) {
                    advanceToNextRound();
                } else if (!currentRound || currentRound.length === 0) {
                    showTournamentResults();
                }
            }
        }

        function advanceToNextRound() {
            const currentRound = gameState.bracket[gameState.currentBracketRound - 1];
            
            if (gameState.currentBracketRound < gameState.bracket.length) {
                const nextRound = gameState.bracket[gameState.currentBracketRound];
                let nextMatchIndex = 0;
                
                for (let i = 0; i < currentRound.length; i += 2) {
                    if (nextMatchIndex < nextRound.length) {
                        nextRound[nextMatchIndex].player1 = currentRound[i].winner;
                        if (i + 1 < currentRound.length) {
                            nextRound[nextMatchIndex].player2 = currentRound[i + 1].winner;
                        }
                        nextMatchIndex++;
                    }
                }
                
                currentRound.forEach(match => {
                    if (match.player1 && match.player1 !== match.winner) {
                        match.player1.isActive = false;
                        gameState.eliminatedPlayers.push(match.player1);
                    }
                    if (match.player2 && match.player2 !== match.winner) {
                        match.player2.isActive = false;
                        gameState.eliminatedPlayers.push(match.player2);
                    }
                });
                
                gameState.currentBracketRound++;
                updateTournamentDisplay();
                startNextMatch();
            } else {
                showTournamentResults();
            }
        }

        function showTournamentResults() {
            document.getElementById('tournamentBracket').classList.add('hidden');
            document.getElementById('createPhase').classList.add('hidden');
            document.getElementById('createPatternPhase').classList.add('hidden');
            document.getElementById('solvePhase').classList.add('hidden');
            document.getElementById('solvePatternPhase').classList.add('hidden');
            document.getElementById('resultsScreen').classList.remove('hidden');
            
            const winner = gameState.bracket[gameState.bracket.length - 1][0].winner;
            document.getElementById('winnerText').textContent = `üèÜ Tournament Champion: ${winner.name}!`;
            
            const allPlayers = [...gameState.players, ...gameState.eliminatedPlayers];
            allPlayers.sort((a, b) => {
                if (a === winner) return -1;
                if (b === winner) return 1;
                if (a.isActive && !b.isActive) return -1;
                if (!a.isActive && b.isActive) return 1;
                return b.score - a.score;
            });
            
            const rankingsList = document.getElementById('rankingsList');
            rankingsList.innerHTML = '';
            
            allPlayers.forEach((player, index) => {
                const rankCard = document.createElement('div');
                rankCard.style.cssText = `
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    background: ${index === 0 ? 'rgba(255, 215, 0, 0.3)' : 'rgba(59, 130, 246, 0.1)'};
                    border: 2px solid ${index === 0 ? '#ffd700' : 'rgba(59, 130, 246, 0.3)'};
                    border-radius: 10px;
                    padding: 15px 20px;
                `;
                
                const medals = ['ü•á', 'ü•à', 'ü•â'];
                const medal = medals[index] || `#${index + 1}`;
                
                rankCard.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <div style="font-size: 1.5rem;">${medal}</div>
                        <div>
                            <div style="font-weight: bold; font-size: 1.1rem;">${player.name}</div>
                            <div style="opacity: 0.8; font-size: 0.9rem;">
                                ${index === 0 ? 'Champion' : player.isActive ? 'Finalist' : 'Eliminated'}
                            </div>
                        </div>
                    </div>
                    <div style="font-size: 1.3rem; font-weight: bold; color: #ffd700;">
                        ${player.score}
                    </div>
                `;
                
                rankingsList.appendChild(rankCard);
            });
        }

        function startCreatePhase() {
            gameState.phase = 'create';
            gameState.timeLeft = 120;
            
            sendMessage({
                type: 'gameState',
                state: {
                    phase: gameState.phase,
                    currentCreator: gameState.currentCreator,
                    currentRound: gameState.currentRound,
                    timeLeft: gameState.timeLeft
                }
            });
            
            const waitingDiv = document.getElementById('waitingScreen');
            if (waitingDiv) {
                waitingDiv.style.display = 'none';
            }
            
            document.getElementById('createPhase').classList.add('hidden');
            document.getElementById('createPatternPhase').classList.add('hidden');
            document.getElementById('solvePhase').classList.add('hidden');
            document.getElementById('solvePatternPhase').classList.add('hidden');
            document.getElementById('resultsScreen').classList.add('hidden');
            
            if (gameState.playerNumber === gameState.currentCreator) {
                if (gameState.gameMode === 'algorithm') {
                    document.getElementById('creatorName').textContent = `Your Turn - Create a Challenge!`;
                    document.getElementById('createPhase').classList.remove('hidden');
                    
                    document.getElementById('challengeTitle').value = '';
                    document.getElementById('challengeDesc').value = '';
                    document.getElementById('functionName').value = '';
                    
                    const testCases = document.getElementById('testCases');
                    testCases.innerHTML = `
                        <div class="test-case">
                            <input type="text" placeholder="Input (e.g., [1,2,3])" class="test-input">
                            <input type="text" placeholder="Expected Output (e.g., 3)" class="test-output">
                            <button type="button" class="remove-test" onclick="removeTestCase(this)">‚úï</button>
                        </div>
                    `;
                } else {
                    document.getElementById('patternCreatorName').textContent = `Your Turn - Create a Pattern!`;
                    document.getElementById('createPatternPhase').classList.remove('hidden');
                    
                    document.getElementById('patternTitle').value = '';
                    document.getElementById('patternDesc').value = '';
                    document.getElementById('patternInput').value = '';
                    document.getElementById('patternPreview').textContent = 'Run your code to see the pattern preview...';
                }
                
                startTimer();
            } else {
                const creatorName = gameState.players.find(p => p.id === gameState.currentCreator)?.name || 'Opponent';
                showWaitingScreen(`${creatorName} is creating a challenge...`);
            }
        }

        function startSolvePhase() {
            gameState.phase = 'solve';
            gameState.timeLeft = 90;
            
            sendMessage({
                type: 'gameState',
                state: {
                    phase: gameState.phase,
                    currentCreator: gameState.currentCreator,
                    currentRound: gameState.currentRound,
                    timeLeft: gameState.timeLeft
                }
            });
            
            const waitingDiv = document.getElementById('waitingScreen');
            if (waitingDiv) {
                waitingDiv.style.display = 'none';
            }
            
            document.getElementById('createPhase').classList.add('hidden');
            document.getElementById('createPatternPhase').classList.add('hidden');
            document.getElementById('solvePhase').classList.add('hidden');
            document.getElementById('solvePatternPhase').classList.add('hidden');
            
            if (gameState.playerNumber !== gameState.currentCreator) {
                if (gameState.currentChallenge.type === 'algorithm') {
                    document.getElementById('solverName').textContent = `Your Turn - Solve the Challenge!`;
                    document.getElementById('solvePhase').classList.remove('hidden');
                    
                    displayChallenge();
                    document.getElementById('codeEditor').value = '';
                    document.getElementById('testResults').classList.add('hidden');
                } else {
                    document.getElementById('patternSolverName').textContent = `Your Turn - Recreate the Pattern!`;
                    document.getElementById('solvePatternPhase').classList.remove('hidden');
                    
                    displayPatternChallenge();
                    document.getElementById('patternSolution').value = '';
                    document.getElementById('patternOutput').textContent = 'Your pattern output will appear here...';
                    document.getElementById('patternResults').classList.add('hidden');
                }
                
                startTimer();
            } else {
                const solverName = gameState.players.find(p => p.id !== gameState.currentCreator && p.isActive)?.name || 'Opponent';
                showWaitingScreen(`${solverName} is solving your challenge...`);
            }
        }

        function startTimer() {
            clearInterval(gameState.timer);
            
            gameState.timer = setInterval(() => {
                gameState.timeLeft--;
                
                sendMessage({
                    type: 'timer',
                    timeLeft: gameState.timeLeft
                });
                
                updateTimerDisplay();
                
                if (gameState.timeLeft <= 0) {
                    clearInterval(gameState.timer);
                    if (gameState.phase === 'create') {
                        if (gameState.gameMode === 'algorithm') {
                            submitChallenge();
                        } else {
                            submitPattern();
                        }
                    } else {
                        if (gameState.currentChallenge.type === 'algorithm') {
                            submitSolution();
                        } else {
                            submitPatternSolution();
                        }
                    }
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(gameState.timeLeft / 60);
            const seconds = gameState.timeLeft % 60;
            document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function addTestCase() {
            const testCases = document.getElementById('testCases');
            const newTestCase = document.createElement('div');
            newTestCase.className = 'test-case';
            newTestCase.innerHTML = `
                <input type="text" placeholder="Input (e.g., [1,2,3])" class="test-input">
                <input type="text" placeholder="Expected Output (e.g., 3)" class="test-output">
                <button type="button" class="remove-test" onclick="removeTestCase(this)">‚úï</button>
            `;
            testCases.appendChild(newTestCase);
        }

        function removeTestCase(button) {
            const testCases = document.getElementById('testCases');
            if (testCases.children.length > 1) {
                button.parentElement.remove();
            }
        }

        function testPattern() {
            const code = document.getElementById('patternInput').value;
            if (!code.trim()) {
                showMessage('Please write some pattern code first!');
                return;
            }
            
            try {
                let output = '';
                const originalLog = console.log;
                console.log = function(...args) {
                    output += args.join(' ') + '\n';
                };
                
                eval(code);
                console.log = originalLog;
                
                document.getElementById('patternPreview').textContent = output || 'No output generated';
            } catch (error) {
                document.getElementById('patternPreview').textContent = 'Error: ' + error.message;
            }
        }

        function submitPattern() {
            const title = document.getElementById('patternTitle').value.trim();
            const desc = document.getElementById('patternDesc').value.trim();
            const code = document.getElementById('patternInput').value.trim();
            
            if (!title || !code) {
                showMessage('Please fill in the pattern title and code!');
                return;
            }
            
            let targetOutput = '';
            try {
                const originalLog = console.log;
                console.log = function(...args) {
                    targetOutput += args.join(' ') + '\n';
                };
                
                eval(code);
                console.log = originalLog;
                
                if (!targetOutput.trim()) {
                    showMessage('Your pattern code must produce output using console.log()!');
                    return;
                }
            } catch (error) {
                showMessage('Error in your pattern code: ' + error.message);
                return;
            }
            
            gameState.currentChallenge = {
                title,
                description: desc,
                code,
                targetPattern: targetOutput.trim(),
                type: 'pattern'
            };
            
            const lines = targetOutput.trim().split('\n').length;
            const creatorScore = 40 + (lines * 5) + Math.floor(gameState.timeLeft / 2);
            const creatorPlayer = gameState.players.find(p => p.id === gameState.currentCreator);
            if (creatorPlayer) {
                creatorPlayer.score += creatorScore;
            }
            
            sendMessage({
                type: 'challenge',
                challenge: gameState.currentChallenge
            });
            
            clearInterval(gameState.timer);
            updateUI();
            startSolvePhase();
        }

        function submitChallenge() {
            const title = document.getElementById('challengeTitle').value.trim();
            const desc = document.getElementById('challengeDesc').value.trim();
            const funcName = document.getElementById('functionName').value.trim();
            
            const testInputs = Array.from(document.querySelectorAll('.test-input')).map(input => input.value.trim());
            const testOutputs = Array.from(document.querySelectorAll('.test-output')).map(input => input.value.trim());
            
            if (!title || !desc || !funcName || testInputs.some(input => !input) || testOutputs.some(output => !output)) {
                showMessage('Please fill in all fields and test cases!');
                return;
            }
            
            gameState.currentChallenge = {
                title,
                description: desc,
                functionName: funcName,
                testCases: testInputs.map((input, i) => ({ input, output: testOutputs[i] })),
                type: 'algorithm'
            };
            
            const creatorScore = 30 + (gameState.currentChallenge.testCases.length * 10) + Math.floor(gameState.timeLeft / 2);
            const creatorPlayer = gameState.players.find(p => p.id === gameState.currentCreator);
            if (creatorPlayer) {
                creatorPlayer.score += creatorScore;
            }
            
            sendMessage({
                type: 'challenge',
                challenge: gameState.currentChallenge
            });
            
            clearInterval(gameState.timer);
            updateUI();
            startSolvePhase();
        }

        function displayChallenge() {
            const challenge = gameState.currentChallenge;
            document.getElementById('displayTitle').textContent = challenge.title;
            document.getElementById('displayDesc').textContent = challenge.description;
            document.getElementById('functionTemplate').textContent = `function ${challenge.functionName}() { /* Your code here */ }`;
            
            const testsDiv = document.getElementById('displayTests');
            testsDiv.innerHTML = challenge.testCases.map((test, i) => 
                `<div style="margin: 5px 0; font-family: monospace; background: rgba(0,0,0,0.2); padding: 8px; border-radius: 4px;">
                    Test ${i + 1}: ${challenge.functionName}(${test.input}) ‚Üí ${test.output}
                </div>`
            ).join('');
        }

        function displayPatternChallenge() {
            const challenge = gameState.currentChallenge;
            document.getElementById('patternDisplayTitle').textContent = challenge.title;
            document.getElementById('patternDisplayDesc').textContent = challenge.description || 'Recreate the pattern shown below using JavaScript code.';
            document.getElementById('targetPattern').textContent = challenge.targetPattern;
        }

        function runPatternCode() {
            const code = document.getElementById('patternSolution').value;
            if (!code.trim()) {
                showMessage('Please write some code first!');
                return;
            }
            
            try {
                let output = '';
                const originalLog = console.log;
                console.log = function(...args) {
                    output += args.join(' ') + '\n';
                };
                
                eval(code);
                console.log = originalLog;
                
                document.getElementById('patternOutput').textContent = output || 'No output generated';
            } catch (error) {
                document.getElementById('patternOutput').textContent = 'Error: ' + error.message;
            }
        }

        function submitPatternSolution() {
            const code = document.getElementById('patternSolution').value;
            const challenge = gameState.currentChallenge;
            
            if (!code.trim()) {
                showMessage('Please write some code first!');
                return;
            }
            
            let userOutput = '';
            try {
                const originalLog = console.log;
                console.log = function(...args) {
                    userOutput += args.join(' ') + '\n';
                };
                
                eval(code);
                console.log = originalLog;
                
                userOutput = userOutput.trim();
            } catch (error) {
                userOutput = 'Error: ' + error.message;
            }
            
            const targetPattern = challenge.targetPattern;
            const accuracy = calculatePatternAccuracy(userOutput, targetPattern);
            
            const resultsDiv = document.getElementById('patternResults');
            resultsDiv.classList.remove('hidden');
            
            const isMatch = userOutput === targetPattern;
            resultsDiv.innerHTML = `
                <div class="test-result ${isMatch ? 'pass' : 'fail'}">
                    <span>${isMatch ? '‚úÖ' : '‚ùå'}</span>
                    <span>Pattern Match: ${accuracy}% accuracy</span>
                </div>
                <div style="margin-top: 15px;">
                    <strong>Expected:</strong>
                    <pre style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin: 5px 0;">${targetPattern}</pre>
                    <strong>Your Output:</strong>
                    <pre style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin: 5px 0;">${userOutput}</pre>
                </div>
            `;
            
            const baseScore = accuracy;
            const timeBonus = Math.floor(gameState.timeLeft / 2);
            const finalScore = Math.floor(baseScore + timeBonus);
            
            const solverPlayer = gameState.players.find(p => p.id !== gameState.currentCreator && p.isActive);
            if (solverPlayer) {
                solverPlayer.score += finalScore;
            }
            
            sendMessage({
                type: 'solution',
                accuracy: accuracy,
                score: finalScore,
                solverNumber: gameState.playerNumber,
                userOutput: userOutput,
                isPatternMatch: isMatch
            });
            
            clearInterval(gameState.timer);
            updateUI();
            
            setTimeout(() => {
                nextRound();
            }, 4000);
        }

        function calculatePatternAccuracy(userOutput, targetPattern) {
            if (userOutput === targetPattern) return 100;
            
            const userLines = userOutput.split('\n');
            const targetLines = targetPattern.split('\n');
            
            if (userLines.length !== targetLines.length) {
                const lengthSimilarity = Math.min(userLines.length, targetLines.length) / Math.max(userLines.length, targetLines.length);
                return Math.floor(lengthSimilarity * 50);
            }
            
            let matchingLines = 0;
            for (let i = 0; i < targetLines.length; i++) {
                if (userLines[i] === targetLines[i]) {
                    matchingLines++;
                }
            }
            
            return Math.floor((matchingLines / targetLines.length) * 100);
        }

        function runCode() {
            const code = document.getElementById('codeEditor').value;
            const challenge = gameState.currentChallenge;
            
            if (!code.trim()) {
                showMessage('Please write some code first!');
                return;
            }
            
            const results = testCode(code, challenge);
            displayTestResults(results);
        }

        function testCode(code, challenge) {
            const results = [];
            
            try {
                const func = new Function('return ' + code)();
                
                if (typeof func !== 'function') {
                    throw new Error('Code must define a function');
                }
                
                challenge.testCases.forEach((test, i) => {
                    try {
                        const input = eval(test.input);
                        const expected = eval(test.output);
                        const actual = func(input);
                        
                        const passed = JSON.stringify(actual) === JSON.stringify(expected);
                        results.push({
                            testNumber: i + 1,
                            input: test.input,
                            expected: test.output,
                            actual: actual,
                            passed: passed
                        });
                    } catch (error) {
                        results.push({
                            testNumber: i + 1,
                            input: test.input,
                            expected: test.output,
                            actual: 'Error: ' + error.message,
                            passed: false
                        });
                    }
                });
            } catch (error) {
                results.push({
                    testNumber: 'All',
                    input: 'N/A',
                    expected: 'Valid function',
                    actual: 'Error: ' + error.message,
                    passed: false
                });
            }
            
            return results;
        }

        function displayTestResults(results) {
            const resultsDiv = document.getElementById('testResults');
            resultsDiv.classList.remove('hidden');
            
            resultsDiv.innerHTML = results.map(result => 
                `<div class="test-result ${result.passed ? 'pass' : 'fail'}">
                    <span>${result.passed ? '‚úÖ' : '‚ùå'}</span>
                    <span>Test ${result.testNumber}: Input(${result.input}) ‚Üí Expected: ${result.expected}, Got: ${result.actual}</span>
                </div>`
            ).join('');
        }

        function submitSolution() {
            const code = document.getElementById('codeEditor').value;
            const challenge = gameState.currentChallenge;
            
            if (!code.trim()) {
                showMessage('Please write some code first!');
                return;
            }
            
            const results = testCode(code, challenge);
            displayTestResults(results);
            
            const passedTests = results.filter(r => r.passed).length;
            const totalTests = challenge.testCases.length;
            const baseScore = (passedTests / totalTests) * 100;
            const timeBonus = Math.floor(gameState.timeLeft / 2);
            const finalScore = Math.floor(baseScore + timeBonus);
            
            const solverPlayer = gameState.players.find(p => p.id !== gameState.currentCreator && p.isActive);
            if (solverPlayer) {
                solverPlayer.score += finalScore;
            }
            
            sendMessage({
                type: 'solution',
                results: results,
                score: finalScore,
                solverNumber: gameState.playerNumber
            });
            
            clearInterval(gameState.timer);
            updateUI();
            
            setTimeout(() => {
                nextRound();
            }, 3000);
        }

        function handleRemoteSolution(data) {
            const solverPlayer = gameState.players.find(p => p.id === data.solverNumber);
            if (solverPlayer) {
                solverPlayer.score += data.score;
            }
            
            updateUI();
            
            if (data.results) {
                showMessage(`Your opponent scored ${data.score} points! (${data.results.filter(r => r.passed).length}/${data.results.length} tests passed)`);
            } else {
                showMessage(`Your opponent scored ${data.score} points! (${data.accuracy}% pattern accuracy)`);
            }
            
            setTimeout(() => {
                nextRound();
            }, 3000);
        }

        function completeMatch(winner) {
            const currentRound = gameState.bracket[gameState.currentBracketRound - 1];
            const currentMatchIndex = currentRound.findIndex(match => 
                match.player1?.id === gameState.currentMatch.player1?.id && 
                match.player2?.id === gameState.currentMatch.player2?.id
            );
            
            if (currentMatchIndex !== -1) {
                currentRound[currentMatchIndex].winner = winner;
                currentRound[currentMatchIndex].completed = true;
                
                updateBracketDisplay();
                
                sendMessage({
                    type: 'matchComplete',
                    winner: winner,
                    bracket: gameState.bracket,
                    currentBracketRound: gameState.currentBracketRound
                });
                
                setTimeout(() => {
                    startNextMatch();
                }, 2000);
            }
        }

        function nextRound() {
            if (gameState.phase === 'tournament') {
                const player1 = gameState.currentMatch.player1;
                const player2 = gameState.currentMatch.player2;
                
                if (player1 && player2) {
                    const winner = player1.score >= player2.score ? player1 : player2;
                    completeMatch(winner);
                } else {
                    startNextMatch();
                }
            }
        }

        function syncGamePhase() {
            document.getElementById('createPhase').classList.add('hidden');
            document.getElementById('createPatternPhase').classList.add('hidden');
            document.getElementById('solvePhase').classList.add('hidden');
            document.getElementById('solvePatternPhase').classList.add('hidden');
            document.getElementById('resultsScreen').classList.add('hidden');
            
            if (gameState.phase === 'create') {
                if (gameState.playerNumber === gameState.currentCreator) {
                    if (gameState.gameMode === 'algorithm') {
                        document.getElementById('createPhase').classList.remove('hidden');
                    } else {
                        document.getElementById('createPatternPhase').classList.remove('hidden');
                    }
                } else {
                    showWaitingScreen('Your opponent is creating a challenge...');
                }
            } else if (gameState.phase === 'solve') {
                if (gameState.playerNumber !== gameState.currentCreator) {
                    if (gameState.currentChallenge.type === 'algorithm') {
                        document.getElementById('solvePhase').classList.remove('hidden');
                        displayChallenge();
                    } else {
                        document.getElementById('solvePatternPhase').classList.remove('hidden');
                        displayPatternChallenge();
                    }
                } else {
                    showWaitingScreen('Your opponent is solving your challenge...');
                }
            }
        }

        function showWaitingScreen(message) {
            let waitingDiv = document.getElementById('waitingScreen');
            if (!waitingDiv) {
                waitingDiv = document.createElement('div');
                waitingDiv.id = 'waitingScreen';
                waitingDiv.style.cssText = `
                    text-align: center;
                    padding: 60px 40px;
                    background: rgba(255, 215, 0, 0.1);
                    border-radius: 20px;
                    border: 2px solid rgba(255, 215, 0, 0.3);
                `;
                document.querySelector('.phase-content').appendChild(waitingDiv);
            }
            
            waitingDiv.innerHTML = `
                <div style="font-size: 3rem; margin-bottom: 20px;">‚è≥</div>
                <h3 style="color: #ffd700; margin-bottom: 15px;">${message}</h3>
                <div style="opacity: 0.8;">Please wait while your opponent completes their turn...</div>
            `;
            waitingDiv.style.display = 'block';
        }

        function showMessage(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(45deg, #3b82f6, #10b981);
                color: white;
                padding: 15px 25px;
                border-radius: 10px;
                font-weight: bold;
                z-index: 1000;
                box-shadow: 0 10px 25px rgba(59, 130, 246, 0.3);
                border: 2px solid rgba(255, 255, 255, 0.2);
                animation: slideIn 0.3s ease;
                max-width: 300px;
            `;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 4000);
        }

        function resetGame() {
            // Clean up peer connections
            if (peer) {
                peer.destroy();
                peer = null;
            }
            
            connections.clear();
            
            gameState = {
                players: [],
                maxPlayers: 4,
                tournamentName: '',
                currentRound: 1,
                maxRounds: 4,
                currentMatch: { player1: null, player2: null },
                currentCreator: null,
                currentChallenge: null,
                timer: null,
                timeLeft: 120,
                phase: 'lobby',
                gameMode: 'algorithm',
                isHost: false,
                playerNumber: 0,
                connectionId: '',
                isConnected: false,
                bracket: [],
                currentBracketRound: 1,
                eliminatedPlayers: []
            };
            
            isHost = false;
            myPeerId = '';
            
            document.getElementById('modeSelection').style.display = 'block';
            document.getElementById('scoringInfo').style.display = 'none';
            document.getElementById('connectionSetup').style.display = 'none';
            document.getElementById('setup').style.display = 'none';
            document.getElementById('gameArea').style.display = 'none';
            
            document.getElementById('hostInterface').style.display = 'none';
            document.getElementById('joinInterface').style.display = 'none';
            document.getElementById('tournamentLobby').style.display = 'none';
            document.getElementById('joinCode').value = '';
            document.getElementById('playerName').value = '';
            document.getElementById('nameSubmitBtn').style.display = 'block';
            document.getElementById('waitingForOpponent').style.display = 'none';
            document.getElementById('tournamentName').value = '';
            document.getElementById('maxPlayers').value = '4';
            
            document.querySelectorAll('.mode-card').forEach(card => {
                card.style.transform = 'scale(1)';
                card.style.opacity = '1';
            });
            document.getElementById('selectedMode').style.display = 'none';
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            gameState.phase = 'modeSelection';
            
            document.getElementById('modeSelection').style.display = 'block';
            document.getElementById('scoringInfo').style.display = 'none';
            document.getElementById('connectionSetup').style.display = 'none';
            document.getElementById('setup').style.display = 'none';
            document.getElementById('gameArea').style.display = 'none';
        });
    </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'996c7baa24afc51e',t:'MTc2MTg0Mzc3NS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
